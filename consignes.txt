- coder a la norme
- no segmentation fault,bus error, double free
- no leaks, all allocated memory must be freed
- compilation with cc -Wall -Werror -Wextra
- makefile with $(NAME), all, clean, fclean, re
- bonus rule in the makefile, bonus in a separate bonus.c/.h
- variable globales sont interdites

• One or more philosophers sit at a round table.
There is a large bowl of spaghetti in the middle of the table.
• The philosophers alternatively eat, think, or sleep.
While they are eating, they are not thinking nor sleeping;
while thinking, they are not eating nor sleeping;
and, of course, while sleeping, they are not eating nor thinking.
• There are also forks on the table. There are as many forks as philosophers.
• Because serving and eating spaghetti with only one fork is very inconvenient, a
philosopher takes their right and their left forks to eat, one in each hand.
• When a philosopher has finished eating, they put their forks back on the table and
start sleeping. Once awake, they start thinking again. The simulation stops when
a philosopher dies of starvation.
• Every philosopher needs to eat and should never starve.
• Philosophers don’t speak with each other.
• Philosophers don’t know if another philosopher is about to die.
• No need to say that philosophers should avoid dying

- le programme prend comme arguments : number_of_philosophers, time_to_die,
time_to_eat, time_to_sleep, [number_of_time_philo_must_eat].
	number_of_philosophers = nombre de philo et nbr de fourchettes
	time_to_die : temps maximal qui separe le debut d'un repas avec le suivant
				  ou du debut de la simulation avec le 1er repas.
	time_to_eat : temps que dure un repas (cela inclus le temps de prendre les fourchettes)
	time_to_sleep : temps que dure un sommeil
	number_of_time_philo_must_eat (optionnel): lorsque c'est indique,
		le programme s'arrete lorsque chaque philo a mange au moins ce nombre de fois
- les philos sont numerotes de 1 a nbr de philo et disposes dans l'ordre croissant,
le dernier a cote du premier.
tout changement d'etat d'un philo doit etre formatte comme suit :
◦ timestamp_in_ms X has taken a fork
◦ timestamp_in_ms X is eating
◦ timestamp_in_ms X is sleeping
◦ timestamp_in_ms X is thinking
◦ timestamp_in_ms X died
timestamp_in_ms = actuel timestamp en milliseconde
X = philosopher number
- on ne doit pas melanger deux messages,
- le message annoncant la mort d'un philo doit etre affiche 10 milliseconde max
apres la mort du philo.
le programme ne doit pas avoir de course aux donnees.
fonctions autorisees :
- memset : void *memset(void *s, int c, size_t n); initialise les variables de s avec c.
- printf, malloc, free, write,
- usleep : int usleep(useconds_t usec); suspend l'execution du programme durant
usec microseconde. (500000 microsec = 0.5 sec = 500 millisec)
- gettimeofday : int gettimeofday(struct timeval *tv, struct timezone *tz);
remplit la structure tv, avec le temps ecoule depuis le 1er janvier 1970, en sec
et microsec. tz est souvent NULL.
(struct timeval tv avec tv.tv_sec et tv.tv_usec)
- pthread_create : int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
cree un nouveau thread d'execution dont l'identifiant est stocke dans "thread"
les attributs optionnels "attr" sont generalement NULL
une fonction "start_routine" que le thread executera : void *thread_function(void *arg)
un argument "arg" passe a cette fonction.
- pthread_detach : int pthread_detach(pthread_t thread);
detache un thread et le nettoie automatiquement lorsqu'il termine son execution
- pthread_join : int pthread_join(pthread_t thread, void **retval);
attend la terminaison d'un thread et recupere sa valeur de retour si elle n'est pas null.
- pthread_mutex_init : int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t *attr);
initialise un mutex avec les attributs donnes
- pthread_mutex_destroy : int pthread_mutex_destroy(pthread_mutex_t *mutex);
detruit un mutex et libere les ressources associees au mutex
- pthread_mutex_lock : int pthread_mutex_lock(pthread_mutex_t *mutex);
verrouille un mutex, si le mutex est deja verrouille, le thread appelant est bloque
jusqua ce que le mutex soit deverouille. permet de garantir qu'un seul thread
peut acceder a la section critique protegee par le mutex
- pthread_mutex_unlock : int pthread_mutex_unlock(pthread_mutex_t *mutex);
deverouille un mutex precedemment verrouille. d'autres thread peuvent alors y acceder.

chaque philo doit etre un thread
une fourchette entre chaque paire de philo, soit une fourchette a droite et une
fourchette a gauche de chaque philo. si un seul philo, une seule fourchette.
proteger le fork state avec un mutex pour eviter que les forks soient dupliquees

Bonus :
toutes les fourchettes sont mises au milieu de la table
le nombre de fourchette dispo est represente par un semaphore
tous les philo doivent etre un process mais le main process n'est pas un philo

on peut detecter les erreurs de thread en utilisant "valgrind --tool=helgrind ./philosophers"
 ou  "valgrind --tool=drd ./programme."
